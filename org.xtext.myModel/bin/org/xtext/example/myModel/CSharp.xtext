grammar org.xtext.example.myModel.CSharp hidden(WS, ML_COMMENT, SL_COMMENT)

generate cSharp 'http://www.xtext.org/example/myModel/CSharp'
import 'http://www.eclipse.org/emf/2002/Ecore' as ecore

Model:
	inputs+=Input*;

Input:
	InputSectionPart*;
	//LEXICA
InputSectionPart:
	(InputElement)* NEW_LINE
	| PPDirective;

PPDirective:
	PPDeclaration
	| PPConditional
	| PPLine
	| PPDiagnostic
	| PPRegion;

PPRegion:
	PPStartRegion /*conditional-section?*/ PPEndRegion;

PPEndRegion:
	PPInitialSection "endregion" WS? PPMessage;

PPStartRegion:
	PPInitialSection "region" WS? PPMessage;

PPDiagnostic:
	PPInitialSection ("error" WS? PPMessage
	| "warning" WS? PPMessage);

PPMessage:
	Input* NEW_LINE;

PPLine:
	PPInitialSection 'line' WS? LineIndicator PPNewLine;

LineIndicator:
	INT+ WS FileName
	| INT+
	| 'default';

FileName:
	'"' FileNameCharacters '"';

FileNameCharacters:
	SINGLE_CHARACTER FileNameCharacters2;

FileNameCharacters2:
	(SINGLE_CHARACTER FileNameCharacters2)*;

PPInitialSection:
	WS? '#' WS?;

PPConditional:
	PPIfSection PPElifSections? => PPElseSection? PPEndif;

PPEndif:
	PPInitialSection 'endif' PPNewLine;

PPElseSection:
	PPInitialSection 'else' PPNewLine (WS)* //ConditionalSection? 
;

PPElifSections:
	PPElifSection PPElifSections2;

PPElifSections2:
	(PPElifSection PPElifSections2)*;

PPElifSection:
	PPInitialSection => 'elif' (WS)* PPExpression PPNewLine (WS)* //ConditionalSection?
;

PPIfSection:
	PPInitialSection 'if' (WS)* PPExpression PPNewLine (WS)* //ConditionalSection?
;

PPExpression:
	PPOrExpression;

PPOrExpression:
	PPAndExpression (WS)* PPOrExpression2;

PPOrExpression2:
	(=> '||' (WS)* PPAndExpression PPOrExpression2)*;

PPAndExpression:
	PPEqualityExpression (WS)* PPAndExpression2;

PPAndExpression2:
	(=> '&&' (WS)* PPEqualityExpression PPAndExpression2)*;

PPEqualityExpression:
	PPUnaryExpression PPEqualityExpression2*;

PPEqualityExpression2:
	('==' | '!=') (WS)* PPUnaryExpression PPEqualityExpression2;

PPUnaryExpression:
	PPPrimaryExpression
	| '!' PPUnaryExpression;

PPPrimaryExpression:
	'true'
	| 'false'
	| ConditionalSymbol
	| '(' (WS)* PPExpression (WS)* ')';
	/*
ConditionalSection:
	InputSectionPart+
    |SkippedSectionPart+
;

/*
SkippedSectionPart:
	SkippedCharacters? NEW_LINE
    |PPDirective
;

SkippedCharacters:
	 WS? NotNumberSign InputCharacter*
;

InputCharacter:
	('\n'|'\r')* ('\r'? '\n')?// ERRADO??
;

NotNumberSign:
	STRING // ERRADO?
;
*/
PPDeclaration:
	PPInitialSection ('define' | 'undef') WS ConditionalSymbol PPNewLine;

PPNewLine:
	(WS)* SL_COMMENT? NEW_LINE;

ConditionalSymbol:
	IdentifierOrKeyword;

InputElement:
	WS
	| Comment
	| Token;

Token:
	ID
	| Keywords
	| IntegerLiteral
	| RealLiteral
	| CharacterLiteral
	| StringLiteral
	| OPERATOR_OR_PUNCTUATOR;

Keywords:
	'abstract'
	| 'as'
	| 'base'
	| 'break'
	| 'case'
	| 'catch'
	| 'checked'
	| 'class'
	| 'const'
	| 'continue'
	| 'default'
	| 'delegate'
	| 'do'
	| 'else'
	| 'enum'
	| 'event'
	| 'explicit'
	| 'extern'
	| 'false'
	| 'finally'
	| 'fixed'
	| 'for'
	| 'foreach'
	| 'goto'
	| 'if'
	| 'implicit'
	| 'in'
	| 'interface'
	| 'internal'
	| 'is'
	| 'lock'
	| 'namespace'
	| 'new'
	| 'null'
	| 'operator'
	| 'out'
	| 'override'
	| 'params'
	| 'private'
	| 'protected'
	| 'public'
	| 'readonly'
	| 'ref'
	| 'return'
	| 'sealed'
	| 'sizeof'
	| 'stackalloc'
	| 'static'
	| 'struct'
	| 'switch'
	| 'this'
	| 'throw'
	| 'true'
	| 'try'
	| 'typeof'
	| 'unchecked'
	| 'unsafe'
	| 'using'
	| 'virtual'
	| 'void'
	| 'volatile'
	| 'while'
	| PredefinedType;

PredefinedType:
	'bool'
	| 'byte'
	| 'char'
	| 'decimal'
	| 'double'
	| 'float'
	| 'int'
	| 'long'
	| 'object'
	| 'short'
	| 'sbyte'
	| 'string'
	| 'uint'
	| 'ulong'
	'ushort';
	
Literal:
    BooleanLiteral
    |IntegerLiteral
    |RealLiteral
    |CharacterLiteral
    |StringLiteral
    |NullLiteral;

NullLiteral:
  'null'
;

BooleanLiteral:
	'true'
    |'false'
;
	

IntegerLiteral:
	('0x' | '0X') HEX_DIGIT+ INTEGER_TYPE_SUFFIX
	| INT (INTEGER_TYPE_SUFFIX)?;

RealLiteral:
	INT '.' INT ExponentPart? REAL_TYPE_SUFFIX?
	| INT ExponentPart REAL_TYPE_SUFFIX?
	| INT REAL_TYPE_SUFFIX;

ExponentPart:
	'e' OPERATOR_OR_SIGN? INT
	| 'E' OPERATOR_OR_SIGN? INT;

CharacterLiteral:
	"'" Character "'";

Character:
	SINGLE_CHARACTER
	| '\\' EscapeSequence;

EscapeSequence:
	ESCAPE_SEQUENCE
	| HexadecimalEscapeSequence
	| UnicodeCharacterEscapeSequence;

UnicodeCharacterEscapeSequence:
	'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
	| 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;

HexadecimalEscapeSequence:
	'x' HEX_DIGIT (HEX_DIGIT (HEX_DIGIT HEX_DIGIT?)?)?;

StringLiteral:
	'"' RegularStringCharacter* '"'
	| '@' VerbatimStringCharacter* '"';

VerbatimStringCharacter:
	SINGLE_CHARACTER //Any character except "
	| QUOTE_ESCAPE_SEQUENCE;

RegularStringCharacter:
	SINGLE_CHARACTER //Any character except " (U+0022), \ (U+005C), and new-line-character
	| '\\' ESCAPE_SEQUENCE;

Comment:
	SL_COMMENT
	| ML_COMMENT;

Identifier:
	AvailableIdentifier
	| '@' IDENTIFIER_START_CHARACTER;

AvailableIdentifier:
	IdentifierOrKeyword;

IdentifierOrKeyword:
	IDENTIFIER_START_CHARACTER IdentifierPartCharacter*;

IdentifierPartCharacter:
	LETTER
	| INT /*
    |connecting-character
    |combining-character
    |formatting-character */;
//FIM LEXICA 


//SINTAXE
CompilationUnit:
	UsingDirective* GlobalAttributes NamespaceMemberDeclaration*;

NamespaceMemberDeclaration:
	NamespaceDeclaration
	|TypeDeclaration;

NamespaceDeclaration:
	'namespace' QualifiedIdentifier NamespaceBody ';'?;

NamespaceBody:
	'{' UsingDirective* NamespaceMemberDeclaration* '}';

TypeDeclaration:
	ClassDeclaration
	| StructDeclaration
	| InterfaceDeclaration
	| EnumDeclaration
	| DelegateDeclaration;

DelegateDeclaration:
	'delegate' TypeOrVoid Identifier '(' FormalParameterList? ')' ';';

EnumDeclaration:
	'enum' Identifier (':' IntegralType)? EnumBody ';'?;

InterfaceDeclaration:
	'struct' Identifier (':' QualifiedIdentifierList)? InterfaceBody ';'?;

Modifier:
	'new'
	| 'public'
	| 'protected'
	| 'internal'
	| 'private';

InterfaceBody:
	'{' InterfaceMemberDeclaration* '}';

InterfaceMemberDeclaration:
	'new'?
	(InterfaceMethodDeclaration
	| InterfaceEventDeclaration
	| Type (InterfaceIndexerDeclaration | InterfacePropertyDeclaration));

InterfaceIndexerDeclaration:
	'this' '[' FormalParameterList ']' '{' InterfaceAccessors '}';

InterfaceEventDeclaration:
	'event' Type Identifier ';';

InterfacePropertyDeclaration:
	Identifier '{' InterfaceAccessors '}';

InterfaceAccessors:
	Attributes ('get' ';' (Attributes 'set' ';')? | 'set' ';' (Attributes 'get' ';')?);

InterfaceMethodDeclaration:
	TypeOrVoid Identifier '(' FormalParameterList? ')' ';';

StructDeclaration:
	'struct' Identifier (':' QualifiedIdentifierList)? StructBody ';'?;

StructBody:
	'{' StructMemberDeclaration* '}';

StructMemberDeclarations:
	StructMemberDeclaration (StructMemberDeclarations2)*;

StructMemberDeclarations2:
	StructMemberDeclaration StructMemberDeclarations2;

StructMemberDeclaration:
	ConstantDeclaration
	| FieldDeclaration
	| MethodDeclaration
	| PropertyDeclaration
	| EventDeclaration
	| IndexerDeclaration
	| OperatorDeclaration
	| ConstructorDeclaration
	| StaticConstructorDeclaration
	| TypeDeclaration;

ClassDeclaration:
	('abstract'| 'sealed')* 'class' Identifier ClassBase? ClassBody ';'?;

ClassBody:
	'{' ClassMemberDeclaration* '}';

ClassMemberDeclaration:
	Attributes
	( Modifier* (MethodDeclaration
				| ConstantDeclaration
				| FieldDeclaration
				| PropertyDeclaration
				| EventDeclaration
				| IndexerDeclaration
				| TypeDeclaration)
	| OperatorDeclaration
	| ConstructorDeclaration
	| DestructorDeclaration
	| StaticConstructorDeclaration
	);

StaticConstructorDeclaration:
	StaticConstructorModifiers Identifier '(' ')' =>MaybeEmptyBlock;

StaticConstructorModifiers:
	'extern'? 'static'
	| 'static' 'extern';

DestructorDeclaration:
	'extern'? '~' Identifier '(' ')' =>MaybeEmptyBlock;

ConstructorDeclaration:
	ConstructorModifier* ConstructorDeclarator =>MaybeEmptyBlock;

ConstructorDeclarator:
	Identifier '(' FormalParameterList? ')' ConstructorInitializer?;

ConstructorInitializer:
	':' 'base' '(' ArgumentList ')'
	| ':' 'this' '(' ArgumentList ')';

ArgumentList:
	(Argument ',')*;

Argument:
	RefOrOut? Expression;

RefOrOut:
	'ref'
	| 'out';

ConstructorModifier:
	'public'
	| 'protected'
	| 'internal'
	| 'private'
	| 'extern';

OperatorDeclaration:
	OperatorModifier+ OperatorDeclarator =>MaybeEmptyBlock;

OperatorDeclarator:
	UnaryOperatorDeclarator
	| BinaryOperatorDeclarator
	| ConversionOperatorDeclarator;

ConversionOperatorDeclarator:
	ConversionKind 'operator' Type '(' Type Identifier ')';

ConversionKind:
	'implicit'
	| 'explicit';

BinaryOperatorDeclarator:
	Type 'operator' OverloadableBinaryOperator '(' Type Identifier ',' Type Identifier ')';

OverloadableBinaryOperator:
	OPERATOR_OR_SIGN
	| '*'
	| '/'
	| '%'
	| AMPERSAND
	| BAR
	| '^'
	| '<<'
	| '>>'
	| '=='
	| '!='
	| GREATER_THAN
	| LESS_THAN
	| '>='
	| '<=';

UnaryOperatorDeclarator:
	Type 'operator' OverloadableUnaryOperator '(' Type Identifier ')';

OverloadableUnaryOperator:
	OPERATOR_OR_SIGN
	| INCREMENT_DECREMENT
	| '!'
	| '~'
	| 'true'
	| 'false';

OperatorModifier:
	'public'
	| 'static'
	| 'extern';

IndexerDeclaration:
	IndexerModifier* IndexerDeclarator '{' AccessorDeclarations '}';

IndexerDeclarator:
	Type ('this' '[' FormalParameterList ']'
	| QualifiedIdentifier '.' 'this' '[' FormalParameterList ']');

IndexerModifier:
	 'virtual'
	| 'sealed'
	| 'override'
	| 'abstract'
	| 'extern';

EventDeclaration:
	EventModifier* 'event' Type ((VariableDeclarator ',')+ ';' | QualifiedIdentifier '{' EventAccessorDeclarations '}');

EventAccessorDeclarations:
	Attributes (AddAccessorDeclaration Attributes RemoveAccessorDeclaration
	| RemoveAccessorDeclaration Attributes AddAccessorDeclaration);

RemoveAccessorDeclaration:
	'remove' Block;

AddAccessorDeclaration:
	'add' Block;

EventModifier:
	'static'
	| 'virtual'
	| 'sealed'
	| 'override'
	| 'abstract'
	| 'extern';

PropertyDeclaration:
	PropertyModifier* Type QualifiedIdentifier '{' AccessorDeclarations '}';

AccessorDeclarations:
	Attributes (GetAccessorDeclaration Attributes (SetAccessorDeclaration)?
	| SetAccessorDeclaration Attributes (GetAccessorDeclaration)?);

SetAccessorDeclaration:
	'set' MaybeEmptyBlock;

GetAccessorDeclaration:
	'get' MaybeEmptyBlock;

PropertyModifier:
	 'static'
	| 'virtual'
	| 'sealed'
	| 'override'
	| 'abstract'
	| 'extern';

MethodDeclaration:
	MethodHeader =>MaybeEmptyBlock;

MethodHeader:
	MethodModifier* TypeOrVoid WS QualifiedIdentifier '(' FormalParameterList? ')';

FormalParameterList:
	FixedParameters (',' ParameterArray
	| ParameterArray);

ParameterArray:
	Attributes 'params' ArrayType Identifier;

FixedParameters:
	(=> FixedParameter ',')+;

FixedParameter:
	RefOrOut? Type Identifier;

TypeOrVoid:
	Type
	| 'void';

MethodModifier:
	 'static'
	| 'virtual'
	| 'sealed'
	| 'override'
	| 'abstract'
	| 'extern';

FieldDeclaration:
	FieldModifier* Type (VariableDeclarator ',')+ ';';

VariableDeclarator:
	Identifier
	Identifier '=' VariableInitializer;

VariableInitializer:
	Expression |
	ArrayInitializer;

ArrayInitializer:
	'{' '}'
	| '{' (VariableInitializer ',')+ ','? '}';

FieldModifier:
	 'static'
	| 'readonly'
	| 'volatile';

ConstantDeclaration:
	'const' Type (ConstantDeclarator ',')+ ';';

ConstantDeclarator:
	Identifier '=' Expression;

ClassBase:
	':' (QualifiedIdentifierList | BuiltInClassType (',' QualifiedIdentifierList)?);

QualifiedIdentifierList:
	(QualifiedIdentifier ',')+;

GlobalAttributes:
	GlobalAttributeSection*;

GlobalAttributeSection:
	'[' 'assembly' ':' AttributeList ','? ']';

Attributes:
	AttributeSection*;

AttributeSection:
	'[' (AttributeTarget ':')? AttributeList ','? ']';

AttributeTarget:
	'field'
	| 'event'
	| 'method'
	| 'module'
	| 'param'
	| 'property'
	| 'return'
	| 'type';

AttributeList:
	(Attribute ',')+;

Attribute:
	AttributeName AttributeArguments?;

AttributeArguments:
	'(' ExpressionList? ')';

ExpressionList:
	(Expression ',')+;

Expression:
	UnaryExpression (ASSIGNEMENT_OPERATOR Expression)? Expression2;

Expression2:
	('?' Expression ':' Expression Expression2
	| '||' Expression Expression2
	| '&&' Expression Expression2
	| BAR Expression Expression2
	| '^' Expression Expression2
	| AMPERSAND Expression Expression2
	| EXPRESSION_EQUALITY_OPERATOR Expression Expression2
	| ExpressionRelationalOperator Expression Expression2
	| 'is' BuiltInType Expression2
	| ExpressionShiftOperator Expression Expression2
	| OPERATOR_OR_SIGN Expression Expression2
	| '*' Expression Expression2
	| '/' Expression Expression2
	| '%' Expression Expression2)*;

UnaryExpression:
	(ExpressionUnaryOperator|'(' Type ')') UnaryExpression
	| PrimaryExpression;

ExpressionUnaryOperator:
	OPERATOR_OR_PUNCTUATOR
	| INCREMENT_DECREMENT
	| '!'
	| '~'
	| '*';

ExpressionShiftOperator:
	'<<'
	| '>>';

ExpressionRelationalOperator:
	LESS_THAN
	| GREATER_THAN
	| '<='
	| '>='
	| 'is'
	| 'as';

AttributeName:
	QualifiedIdentifier;

UsingDirective:
	'using' (Identifier '=')? QualifiedIdentifier ';';

Type:
	NonArrayType RANK_SPECIFIER*;

IntegralType:
	'sbyte'
	| 'byte'
	| 'short'
	| 'ushort'
	| 'int'
	| 'uint'
	| 'long'
	| 'ulong'
	| 'char';

ArrayType:
	NonArrayType RANK_SPECIFIER+;

EnumType:
	Attributes EnumModifier* 'enum' ID (':' IntegralType)? EnumBody
	';'?;

NonArrayType:
	QualifiedIdentifier |
	BuiltInType;

QualifiedIdentifier:
	(Identifier '.')+;

BuiltInType:
	IntegralType | BuiltInClassType | 'bool' | 'decimal' | 'float' | 'double';

BuiltInClassType:
	'object' | 'string';

EnumBody:
	'{' '}'
	| '{' (EnumMemberDeclaration ',')+ ','? '}';

EnumMemberDeclaration:
	Attributes Identifier ('=' Expression)?;

EnumModifier:
	'new' | 'public' | 'protected' | 'internal' | 'private';

Statement:
/*LabeledStatement |
    DeclarationStatement |*/
	EmbeddedStatement;

EmbeddedStatement:
	MaybeEmptyBlock 
	| StatementExpression ';' 
	| SelectionStatement 
	| IterationStatement 
	| JumpStatement 
	| TryStatement 
	|('checked'|'unchecked') Block 
	| LockStatement 
	| UsingStatement;

UsingStatement:
	'using' '(' ResourceAquisition ')' EmbeddedStatement;

ResourceAquisition:
	LocalVariableDeclaration | Expression;

LocalVariableDeclaration:
	Type (VariableDeclarator ',')+;

LockStatement:
	'lock' '(' Expression ')' EmbeddedStatement;

TryStatement:
	'try' Block( (CatchClauses (FinallyClause)?) | (FinallyClause));

FinallyClause:
	'finally' Block;

CatchClauses:
	(SpecificCatchClause)+ (GeneralCatchClause)? | (SpecificCatchClause)* =>GeneralCatchClause;

GeneralCatchClause:
	'catch' Block;

SpecificCatchClause:
	'catch' '(' (BuiltInClassType| QualifiedIdentifier) Identifier? ')' Block;

JumpStatement:
	BreakStatement 
	| ContinueStatement 
	| GotoStatement 
	| ReturnStatement 
	| ThrowStatement;

ThrowStatement:
	'throw' Expression? ';';

ReturnStatement:
	'return' Expression? ';';

GotoStatement:
	'goto' Identifier ';' 'goto' 'case' Expression ';' 'goto' 'default' ';';

ContinueStatement:
	'continue' ';';

BreakStatement:
	'break' ';';

IterationStatement:
	WhileStatement 
	| DoStatement 
	| ForStatement 
	| ForeachStatement;

ForeachStatement:
	'foreach' '(' Type Identifier 'in' Expression ')' EmbeddedStatement;

ForStatement:
	'for' '(' ForInitializer? ';' Expression? ';' StatementExpressionList? ')' EmbeddedStatement;

ForInitializer:
	LocalVariableDeclaration 
	| StatementExpressionList;

StatementExpressionList:
	(StatementExpression ',')+;

StatementExpression:
	(PrimaryExpression (('(' ArgumentList ')') | (INCREMENT_DECREMENT))) 
	| 'new' Type '(' ArgumentList ')' 
	| UnaryExpression ASSIGNEMENT_OPERATOR Expression 
	| INCREMENT_DECREMENT PrimaryExpression;

PrimaryExpression:
		(('new' ((NonArrayType '[' ExpressionList ']' RANK_SPECIFIER* ArrayInitializer?)
		    |(ArrayType ArrayInitializer) 
			| (Type	'(' ArgumentList ')'))) 
		| (Identifier)
		| Literal 
		|'(' Expression ')'
		| ('base' (('.' Identifier) 
		| ('[' ExpressionList ']'))) 
		| PredefinedType '.' Identifier 
		| ('this') | ('typeof' '(' TypeOrVoid ')') 
		| ('checked' '(' Expression ')')
		| ('unchecked' '(' Expression ')')) PrimaryExpression2;

PrimaryExpression2:
	((('.' Identifier) 
	  |('(' ArgumentList ')') 
	  |('[' ExpressionList ']') 
	  | (INCREMENT_DECREMENT)
	) PrimaryExpression2)*;

DoStatement:
	'do' EmbeddedStatement 'while' '(' Expression ')' ';';

WhileStatement:
	'while' '(' Expression ')' EmbeddedStatement;

SelectionStatement:
	IfStatement | SwitchStatement;

SwitchStatement:
	'switch' '(' Expression ')' '{' SwitchSection* '}';

SwitchSection:
	SwitchLabel+ Statement+;

SwitchLabel:
	'case' Expression ':' | 'default' ':';

IfStatement:
	'if' '(' Expression ')' EmbeddedStatement ElsePart?;

ElsePart:
	'else' EmbeddedStatement;

Block:
	'{' Statement* '}';

MaybeEmptyBlock:
	'{' (Statement)* '}' | ';';
	/*/
DeclarationStatement:
	
;

LabeledStatement:
	
;
	
*/
terminal LESS_THAN:
	'<';

terminal GREATER_THAN:
	'>';

terminal BAR:
	'|';

terminal AMPERSAND:
	'&';

terminal INCREMENT_DECREMENT:
	'++' | '--';

terminal OPERATOR_OR_SIGN:
	'+' | '-';

terminal REAL_TYPE_SUFFIX:
	'F' | 'f' | 'D' | 'd' | 'M' | 'm';

terminal LETTER:
	('A'..'Z') | ('a'..'z');

terminal IDENTIFIER_START_CHARACTER:
	LETTER | '_';

terminal QUOTE_ESCAPE_SEQUENCE:
	'""';

terminal ESCAPE_SEQUENCE:
	("'" | '"' | "\\" | '0' | 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v');

terminal NEW_LINE:
	('\r' | '\n')*;

terminal RANK_SPECIFIER:
	'[' ','* ']';

terminal INTEGER_TYPE_SUFFIX:
	'U' | 'u' | 'L' | 'l' | 'UL' | 'Ul' | 'uL' | 'ul' | 'LU' | 'Lu' | 'lU' | 'lu';

terminal HEX_DIGIT:
	('0'..'9') | (('A'..'F') | ('a'..'f'));

terminal EXPRESSION_EQUALITY_OPERATOR:
	'=='
	| '!=';

terminal ASSIGNEMENT_OPERATOR:
	'=' |
	'+=' |
	'-=' |
	'*=' |
	'/=' |
	'%=' |
	'&=' |
	'^=' |
	'<<=' |
	'>>=';

terminal OPERATOR_OR_PUNCTUATOR:
	'{'
	| '}'
	| '['
	| ']'
	| '('
	| ')'
	| '.'
	| ','
	| ':'
	| ';'
	| '+'
	| '-'
	| '*'
	| '/'
	| '%'
	| '&'
	| '|'
	| '^'
	| '!'
	| '~'
	| '<'
	| '>'
	| '?'
	| '++'
	| '--'
	| '&&'
	| '||'
	| '<<'
	| '>>'
	| '<='
	| '>='
	| '->'
	| ASSIGNEMENT_OPERATOR
	| EXPRESSION_EQUALITY_OPERATOR;

terminal SINGLE_CHARACTER:
	!("'" | '\\' | NEW_LINE)+;

terminal ID:
	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal INT returns ecore::EInt:
	('0'..'9')+;

terminal STRING:
	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | '"'))* '"'
	| "'" ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | "'"))* "'";

terminal ML_COMMENT:
	'/*'->'*/';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
	(' ' | '\t')+;



 

	